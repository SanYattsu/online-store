global:
  image:
    # -- Overrides the Docker registry globally for all images
    registry: null
  # -- Overrides the priorityClassName for all pods
  priorityClassName: null
  # -- configures cluster domain ("cluster.local" by default)
  clusterDomain: "cluster.local"
  # -- configures DNS service name
  dnsService: "kube-dns"
  # -- configures DNS service namespace
  dnsNamespace: "kube-system"
# -- Overrides the chart's name
nameOverride: null
# -- Overrides the chart's computed fullname
fullnameOverride: null
# -- Overrides the chart's cluster label
clusterLabelOverride: null
# -- Image pull secrets for Docker images
imagePullSecrets: []
# -- Deployment mode lets you specify how to deploy Loki.
# There are 3 options:
# - SingleBinary: Loki is deployed as a single binary, useful for small installs typically without HA, up to a few tens of GB/day.
# - SimpleScalable: Loki is deployed as 3 targets: read, write, and backend. Useful for medium installs easier to manage than distributed, up to a about 1TB/day.
# - Distributed: Loki is deployed as individual microservices. The most complicated but most capable, useful for large installs, typically over 1TB/day.
# There are also 2 additional modes used for migrating between deployment modes:
# - SingleBinary<->SimpleScalable: Migrate from SingleBinary to SimpleScalable (or vice versa)
# - SimpleScalable<->Distributed: Migrate from SimpleScalable to Distributed (or vice versa)
# Note: SimpleScalable and Distributed REQUIRE the use of object storage.
deploymentMode: SingleBinary
######################################################################################################################
#
# Base Loki Configs including kubernetes configurations and configurations for Loki itself,
# see below for more specifics on Loki's configuration.
#
######################################################################################################################
# -- Configuration for running Loki
loki:
  # Configures the readiness probe for all of the Loki pods
  readinessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 30
    timeoutSeconds: 1
  image:
    # -- The Docker registry
    registry: docker.io
    # -- Docker image repository
    repository: grafana/loki
    # -- Overrides the image tag whose default is the chart's appVersion
    # TODO: needed for 3rd target backend functionality
    # revert to null or latest once this behavior is relased
    tag: null
    # -- Overrides the image tag with an image digest
    digest: null
    # -- Docker image pull policy
    pullPolicy: IfNotPresent
  # -- Common annotations for all deployments/StatefulSets
  annotations: {}
  # -- Common annotations for all pods
  podAnnotations: {}
  # -- Common labels for all pods
  podLabels: {}
  # -- Common annotations for all services
  serviceAnnotations: {}
  # -- Common labels for all services
  serviceLabels: {}
  # -- The number of old ReplicaSets to retain to allow rollback
  revisionHistoryLimit: 10
  # -- The SecurityContext for Loki pods
  podSecurityContext:
    fsGroup: 10001
    runAsGroup: 10001
    runAsNonRoot: true
    runAsUser: 10001
  # -- The SecurityContext for Loki containers
  containerSecurityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop:
      - ALL
    allowPrivilegeEscalation: false
  # -- Should enableServiceLinks be enabled. Default to enable
  enableServiceLinks: true
  ######################################################################################################################
  #
  # Loki Configuration
  #
  # There are several ways to pass configuration to Loki, listing them here in order of our preference for how
  # you should use this chart.
  # 1. Use the templated value of loki.config below and the corresponding override sections which follow.
  #    This allows us to set a lot of important Loki configurations and defaults and also allows us to maintain them
  #    over time as Loki changes and evolves.
  # 2. Use the loki.structuredConfig section.
  #    This will completely override the templated value of loki.config, so you MUST provide the entire Loki config
  #    including any configuration that we set in loki.config unless you explicitly are trying to change one of those
  #    values and are not able to do so with the templated sections.
  #    If you choose this approach the burden is on you to maintain any changes we make to the templated config.
  # 3. Use an existing secret or configmap to provide the configuration.
  #    This option is mostly provided for folks who have external processes which provide or modify the configuration.
  #    When using this option you can specify a different name for loki.generatedConfigObjectName and configObjectName
  #    if you have a process which takes the generated config and modifies it, or you can stop the chart from generating
  #    a config entirely by setting loki.generatedConfigObjectName to
  #
  ######################################################################################################################

  # -- Defines what kind of object stores the configuration, a ConfigMap or a Secret.
  # In order to move sensitive information (such as credentials) from the ConfigMap/Secret to a more secure location (e.g. vault), it is possible to use [environment variables in the configuration](https://grafana.com/docs/loki/latest/configuration/#use-environment-variables-in-the-configuration).
  # Such environment variables can be then stored in a separate Secret and injected via the global.extraEnvFrom value. For details about environment injection from a Secret please see [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables).
  configStorageType: ConfigMap
  # -- The name of the object which Loki will mount as a volume containing the config.
  # If the configStorageType is Secret, this will be the name of the Secret, if it is ConfigMap, this will be the name of the ConfigMap.
  # The value will be passed through tpl.
  configObjectName: '{{ include "loki.name" . }}'
  # -- The name of the Secret or ConfigMap that will be created by this chart.
  # If empty, no configmap or secret will be created.
  # The value will be passed through tpl.
  generatedConfigObjectName: '{{ include "loki.name" . }}'

  # -- Config file contents for Loki
  # @default -- See values.yaml
  config: |
    {{- if .Values.enterprise.enabled}}
    {{- tpl .Values.enterprise.config . }}
    {{- else }}
    auth_enabled: {{ .Values.loki.auth_enabled }}
    {{- end }}

    {{- with .Values.loki.server }}
    server:
      {{- toYaml . | nindent 2}}
    {{- end}}

    pattern_ingester:
      enabled: {{ .Values.loki.pattern_ingester.enabled }}

    memberlist:
    {{- if .Values.loki.memberlistConfig }}
      {{- toYaml .Values.loki.memberlistConfig | nindent 2 }}
    {{- else }}
    {{- if .Values.loki.extraMemberlistConfig}}
    {{- toYaml .Values.loki.extraMemberlistConfig | nindent 2}}
    {{- end }}
      join_members:
        - {{ include "loki.memberlist" . }}
        {{- with .Values.migrate.fromDistributed }}
        {{- if .enabled }}
        - {{ .memberlistService }}
        {{- end }}
        {{- end }}
    {{- end }}

    {{- with .Values.loki.ingester }}
    ingester:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- if .Values.loki.commonConfig}}
    common:
    {{- toYaml .Values.loki.commonConfig | nindent 2}}
      storage:
      {{- include "loki.commonStorageConfig" . | nindent 4}}
    {{- end}}

    {{- with .Values.loki.limits_config }}
    limits_config:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    runtime_config:
      file: /etc/loki/runtime-config/runtime-config.yaml

    {{- with .Values.chunksCache }}
    {{- if .enabled }}
    chunk_store_config:
      chunk_cache_config:
        default_validity: {{ .defaultValidity }}
        background:
          writeback_goroutines: {{ .writebackParallelism }}
          writeback_buffer: {{ .writebackBuffer }}
          writeback_size_limit: {{ .writebackSizeLimit }}
        memcached:
          batch_size: {{ .batchSize }}
          parallelism: {{ .parallelism }}
        memcached_client:
          addresses: dnssrvnoa+_memcached-client._tcp.{{ template "loki.fullname" $ }}-chunks-cache.{{ $.Release.Namespace }}.svc
          consistent_hash: true
          timeout: {{ .timeout }}
          max_idle_conns: 72
    {{- end }}
    {{- end }}

    {{- if .Values.loki.schemaConfig }}
    schema_config:
    {{- toYaml .Values.loki.schemaConfig | nindent 2}}
    {{- end }}

    {{- if .Values.loki.useTestSchema }}
    schema_config:
    {{- toYaml .Values.loki.testSchemaConfig | nindent 2}}
    {{- end }}

    {{ include "loki.rulerConfig" . }}

    {{- if or .Values.tableManager.retention_deletes_enabled .Values.tableManager.retention_period }}
    table_manager:
      retention_deletes_enabled: {{ .Values.tableManager.retention_deletes_enabled }}
      retention_period: {{ .Values.tableManager.retention_period }}
    {{- end }}

    query_range:
      align_queries_with_step: true
      {{- with .Values.loki.query_range }}
      {{- tpl (. | toYaml) $ | nindent 4 }}
      {{- end }}
      {{- if .Values.resultsCache.enabled }}
      {{- with .Values.resultsCache }}
      cache_results: true
      results_cache:
        cache:
          default_validity: {{ .defaultValidity }}
          background:
            writeback_goroutines: {{ .writebackParallelism }}
            writeback_buffer: {{ .writebackBuffer }}
            writeback_size_limit: {{ .writebackSizeLimit }}
          memcached_client:
            consistent_hash: true
            addresses: dnssrvnoa+_memcached-client._tcp.{{ template "loki.fullname" $ }}-results-cache.{{ $.Release.Namespace }}.svc
            timeout: {{ .timeout }}
            update_interval: 1m
      {{- end }}
      {{- end }}

    {{- with .Values.loki.storage_config }}
    storage_config:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.query_scheduler }}
    query_scheduler:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.compactor }}
    compactor:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.analytics }}
    analytics:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.querier }}
    querier:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.index_gateway }}
    index_gateway:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.frontend }}
    frontend:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.frontend_worker }}
    frontend_worker:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    {{- with .Values.loki.distributor }}
    distributor:
      {{- tpl (. | toYaml) $ | nindent 4 }}
    {{- end }}

    tracing:
      enabled: {{ .Values.loki.tracing.enabled }}
  # Should authentication be enabled
  auth_enabled: false
  # -- memberlist configuration (overrides embedded default)
  memberlistConfig: {}
  # -- Extra memberlist configuration
  extraMemberlistConfig: {}
  # -- Tenants list to be created on nginx htpasswd file, with name and password keys
  tenants: []
  # -- Check https://grafana.com/docs/loki/latest/configuration/#server for more info on the server configuration.
  server:
    http_listen_port: 3100
    grpc_listen_port: 9095
    http_server_read_timeout: 600s
    http_server_write_timeout: 600s
  # -- Limits config
  limits_config:
    reject_old_samples: true
    reject_old_samples_max_age: 72h
    max_cache_freshness_per_query: 10m
    split_queries_by_interval: 15m
    query_timeout: 300s
    volume_enabled: true
  # -- Provides a reloadable runtime configuration file for some specific configuration
  runtimeConfig: {}
  # -- Check https://grafana.com/docs/loki/latest/configuration/#common_config for more info on how to provide a common configuration
  commonConfig:
    path_prefix: /var/loki
    replication_factor: 1
    compactor_address: '{{ include "loki.compactorAddress" . }}'
  # -- Storage config. Providing this will automatically populate all necessary storage configs in the templated config.
  storage:
    # Loki requires a bucket for chunks and the ruler. GEL requires a third bucket for the admin API.
    # Please provide these values if you are using object storage.
    # bucketNames:
    #   chunks: FIXME
    #   ruler: FIXME
    #   admin: FIXME
    type: filesystem
    # s3:
    #   s3: null
    #   endpoint: null
    #   region: null
    #   secretAccessKey: null
    #   accessKeyId: null
    #   signatureVersion: null
    #   s3ForcePathStyle: false
    #   insecure: false
    #   http_config: {}
    #   # -- Check https://grafana.com/docs/loki/latest/configure/#s3_storage_config for more info on how to provide a backoff_config
    #   backoff_config: {}
    # gcs:
    #   chunkBufferSize: 0
    #   requestTimeout: "0s"
    #   enableHttp2: true
    # azure:
    #   accountName: null
    #   accountKey: null
    #   connectionString: null
    #   useManagedIdentity: false
    #   useFederatedToken: false
    #   userAssignedId: null
    #   requestTimeout: null
    #   endpointSuffix: null
    # swift:
    #   auth_version: null
    #   auth_url: null
    #   internal: null
    #   username: null
    #   user_domain_name: null
    #   user_domain_id: null
    #   user_id: null
    #   password: null
    #   domain_id: null
    #   domain_name: null
    #   project_id: null
    #   project_name: null
    #   project_domain_id: null
    #   project_domain_name: null
    #   region_name: null
    #   container_name: null
    #   max_retries: null
    #   connect_timeout: null
    #   request_timeout: null
    filesystem:
      chunks_directory: /var/loki/chunks
      rules_directory: /var/loki/rules
    rulerConfig:
      storage:
        type: local
  # -- Configure memcached as an external cache for chunk and results cache. Disabled by default
  # must enable and specify a host for each cache you would like to use.
  memcached:
    chunk_cache:
      enabled: false
      host: ""
      service: "memcached-client"
      batch_size: 256
      parallelism: 10
    results_cache:
      enabled: false
      host: ""
      service: "memcached-client"
      timeout: "500ms"
      default_validity: "12h"
  # -- Check https://grafana.com/docs/loki/latest/configuration/#schema_config for more info on how to configure schemas
  schemaConfig: {}
  # -- a real Loki install requires a proper schemaConfig defined above this, however for testing or playing around
  # you can enable useTestSchema
  schemaConfig:
    configs:
    - from: 2024-04-01
      store: tsdb
      object_store: filesystem
      schema: v13
      index:
        prefix: index_
        period: 24h
  # -- Check https://grafana.com/docs/loki/latest/configuration/#ruler for more info on configuring ruler
  rulerConfig:
    storage:
      type: local
  # useTestSchema: false
  # testSchemaConfig:
  #   configs:
  #   - from: 2024-04-01
  #     store: tsdb
  #     object_store: '{{ include "loki.testSchemaObjectStore" . }}'
  #     schema: v13
  #     index:
  #       prefix: index_
  #       period: 24h
  # -- Structured loki configuration, takes precedence over `loki.config`, `loki.schemaConfig`, `loki.storageConfig`
  structuredConfig: {}
  # -- Additional query scheduler config
  query_scheduler: {}
  # -- Additional storage config
  storage_config:
    boltdb_shipper:
      index_gateway_client:
        server_address: '{{ include "loki.indexGatewayAddress" . }}'
    tsdb_shipper:
      index_gateway_client:
        server_address: '{{ include "loki.indexGatewayAddress" . }}'
    hedging:
      at: "250ms"
      max_per_second: 20
      up_to: 3
  # --  Optional compactor configuration
  compactor: {}
  # --  Optional pattern ingester configuration
  pattern_ingester:
    enabled: false
  # --  Optional analytics configuration
  analytics: {}
  # --  Optional querier configuration
  query_range: {}
  # --  Optional querier configuration
  querier: {}
  # --  Optional ingester configuration
  ingester: {}
  # --  Optional index gateway configuration
  index_gateway:
    mode: simple
  frontend:
    scheduler_address: '{{ include "loki.querySchedulerAddress" . }}'
    tail_proxy_url: '{{ include "loki.querierAddress" . }}'
  frontend_worker:
    scheduler_address: '{{ include "loki.querySchedulerAddress" . }}'
  # -- Optional distributor configuration
  distributor: {}
  # -- Enable tracing
  tracing:
    enabled: false
######################################################################################################################
#
# Enterprise Loki Configs
#
######################################################################################################################

# # -- Configuration for running Enterprise Loki
# enterprise:
#   # Enable enterprise features, license must be provided
#   enabled: false
#   # Default verion of GEL to deploy
#   version: v3.0.0
#   # -- Optional name of the GEL cluster, otherwise will use .Release.Name
#   # The cluster name must match what is in your GEL license
#   cluster_name: null
#   # -- Grafana Enterprise Logs license
#   # In order to use Grafana Enterprise Logs features, you will need to provide
#   # the contents of your Grafana Enterprise Logs license, either by providing the
#   # contents of the license.jwt, or the name Kubernetes Secret that contains your
#   # license.jwt.
#   # To set the license contents, use the flag `--set-file 'enterprise.license.contents=./license.jwt'`
#   license:
#     contents: "NOTAVALIDLICENSE"
#   # -- Set to true when providing an external license
#   useExternalLicense: false
#   # -- Name of external license secret to use
#   externalLicenseName: null
#   # -- Name of the external config secret to use
#   externalConfigName: ""
#   # -- Use GEL gateway, if false will use the default nginx gateway
#   gelGateway: true
#   # -- If enabled, the correct admin_client storage will be configured. If disabled while running enterprise,
#   # make sure auth is set to `type: trust`, or that `auth_enabled` is set to `false`.
#   adminApi:
#     enabled: true
#   # enterprise specific sections of the config.yaml file
#   config: |
#     {{- if .Values.enterprise.adminApi.enabled }}
#     {{- if or .Values.minio.enabled (eq .Values.loki.storage.type "s3") (eq .Values.loki.storage.type "gcs") (eq .Values.loki.storage.type "azure") }}
#     admin_client:
#       storage:
#         s3:
#           bucket_name: admin
#     {{- end }}
#     {{- end }}
#     auth:
#       type: {{ .Values.enterprise.adminApi.enabled | ternary "enterprise" "trust" }}
#     auth_enabled: {{ .Values.loki.auth_enabled }}
#     cluster_name: {{ include "loki.clusterName" . }}
#     license:
#       path: /etc/loki/license/license.jwt
#   image:
#     # -- The Docker registry
#     registry: docker.io
#     # -- Docker image repository
#     repository: grafana/enterprise-logs
#     # -- Docker image tag
#     tag: null
#     # -- Overrides the image tag with an image digest
#     digest: null
#     # -- Docker image pull policy
#     pullPolicy: IfNotPresent
#   adminToken:
#     # -- Alternative name for admin token secret, needed by tokengen and provisioner jobs
#     secret: null
#     # -- Additional namespace to also create the token in. Useful if your Grafana instance
#     # is in a different namespace
#     additionalNamespaces: []
#   # -- Alternative name of the secret to store token for the canary
#   canarySecret: null
#   # -- Configuration for `tokengen` target
#   tokengen:
#     # -- Whether the job should be part of the deployment
#     enabled: true
#     # -- Comma-separated list of Loki modules to load for tokengen
#     targetModule: "tokengen"
#     # -- Additional CLI arguments for the `tokengen` target
#     extraArgs: []
#     # -- Additional Kubernetes environment
#     env: []
#     # -- Additional labels for the `tokengen` Job
#     labels: {}
#     # -- Additional annotations for the `tokengen` Job
#     annotations: {}
#     # -- Tolerations for tokengen Job
#     tolerations: []
#     # -- Additional volumes for Pods
#     extraVolumes: []
#     # -- Additional volume mounts for Pods
#     extraVolumeMounts: []
#     # -- Run containers as user `enterprise-logs(uid=10001)`
#     securityContext:
#       runAsNonRoot: true
#       runAsGroup: 10001
#       runAsUser: 10001
#       fsGroup: 10001
#     # -- Environment variables from secrets or configmaps to add to the tokengen pods
#     extraEnvFrom: []
#     # -- The name of the PriorityClass for tokengen Pods
#     priorityClassName: ""
#   # -- Configuration for `provisioner` target
#   provisioner:
#     # -- Whether the job should be part of the deployment
#     enabled: true
#     # -- Name of the secret to store provisioned tokens in
#     provisionedSecretPrefix: null
#     # -- Additional tenants to be created. Each tenant will get a read and write policy
#     # and associated token. Tenant must have a name and a namespace for the secret containting
#     # the token to be created in. For example
#     # additionalTenants:
#     #   - name: loki
#     #     secretNamespace: grafana
#     additionalTenants: []
#     # -- Additional Kubernetes environment
#     env: []
#     # -- Additional labels for the `provisioner` Job
#     labels: {}
#     # -- Additional annotations for the `provisioner` Job
#     annotations: {}
#     # -- The name of the PriorityClass for provisioner Job
#     priorityClassName: null
#     # -- Run containers as user `enterprise-logs(uid=10001)`
#     securityContext:
#       runAsNonRoot: true
#       runAsGroup: 10001
#       runAsUser: 10001
#       fsGroup: 10001
#     # -- Provisioner image to Utilize
#     image:
#       # -- The Docker registry
#       registry: docker.io
#       # -- Docker image repository
#       repository: grafana/enterprise-logs-provisioner
#       # -- Overrides the image tag whose default is the chart's appVersion
#       tag: null
#       # -- Overrides the image tag with an image digest
#       digest: null
#       # -- Docker image pull policy
#       pullPolicy: IfNotPresent
#     # -- Volume mounts to add to the provisioner pods
#     extraVolumeMounts: []
# # -- kubetclImage is used in the enterprise provisioner and tokengen jobs
# kubectlImage:
#   # -- The Docker registry
#   registry: docker.io
#   # -- Docker image repository
#   repository: bitnami/kubectl
#   # -- Overrides the image tag whose default is the chart's appVersion
#   tag: null
#   # -- Overrides the image tag with an image digest
#   digest: null
#   # -- Docker image pull policy
#   pullPolicy: IfNotPresent
######################################################################################################################
#
# Chart Testing
#
######################################################################################################################

# # -- Section for configuring optional Helm test
test:
  enabled: false
#   # -- Used to directly query the metrics endpoint of the canary for testing, this approach avoids needing prometheus for testing.
#   # This in a newer approach to using prometheusAddress such that tests do not have a dependency on prometheus
#   canaryServiceAddress: "http://loki-canary:3500/metrics"
#   # -- Address of the prometheus server to query for the test. This overrides any value set for canaryServiceAddress.
#   # This is kept for backward compatibility and may be removed in future releases. Previous value was 'http://prometheus:9090'
#   prometheusAddress: ""
#   # -- Number of times to retry the test before failing
#   timeout: 1m
#   # -- Additional labels for the test pods
#   labels: {}
#   # -- Additional annotations for test pods
#   annotations: {}
#   # -- Image to use for loki canary
#   image:
#     # -- The Docker registry
#     registry: docker.io
#     # -- Docker image repository
#     repository: grafana/loki-helm-test
#     # -- Overrides the image tag whose default is the chart's appVersion
#     tag: "ewelch-distributed-helm-chart-17db5ee"
#     # -- Overrides the image tag with an image digest
#     digest: null
#     # -- Docker image pull policy
#     pullPolicy: IfNotPresent
# # The Loki canary pushes logs to and queries from this loki installation to test
# # that it's working correctly
lokiCanary:
  enabled: false
#   # -- If true, the canary will send directly to Loki via the address configured for verification --
#   # -- If false, it will write to stdout and an Agent will be needed to scrape and send the logs --
#   push: true
#   # -- The name of the label to look for at loki when doing the checks.
#   labelname: pod
#   # -- Additional annotations for the `loki-canary` Daemonset
#   annotations: {}
#   # -- Additional labels for each `loki-canary` pod
#   podLabels: {}
#   service:
#     # -- Annotations for loki-canary Service
#     annotations: {}
#     # -- Additional labels for loki-canary Service
#     labels: {}
#   # -- Additional CLI arguments for the `loki-canary' command
#   extraArgs: []
#   # -- Environment variables to add to the canary pods
#   extraEnv: []
#   # -- Environment variables from secrets or configmaps to add to the canary pods
#   extraEnvFrom: []
#   # -- Volume mounts to add to the canary pods
#   extraVolumeMounts: []
#   # -- Volumes to add to the canary pods
#   extraVolumes: []
#   # -- Resource requests and limits for the canary
#   resources: {}
#   # -- DNS config for canary pods
#   dnsConfig: {}
#   # -- Node selector for canary pods
#   nodeSelector: {}
#   # -- Tolerations for canary pods
#   tolerations: []
#   # -- The name of the PriorityClass for loki-canary pods
#   priorityClassName: null
#   # -- Image to use for loki canary
#   image:
#     # -- The Docker registry
#     registry: docker.io
#     # -- Docker image repository
#     repository: grafana/loki-canary
#     # -- Overrides the image tag whose default is the chart's appVersion
#     tag: null
#     # -- Overrides the image tag with an image digest
#     digest: null
#     # -- Docker image pull policy
#     pullPolicy: IfNotPresent
#   # -- Update strategy for the `loki-canary` Daemonset pods
#   updateStrategy:
#     type: RollingUpdate
#     rollingUpdate:
#       maxUnavailable: 1
######################################################################################################################
#
# Service Accounts and Kubernetes RBAC
#
######################################################################################################################
serviceAccount:
  # -- Specifies whether a ServiceAccount should be created
  create: true
  # -- The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name: null
  # -- Image pull secrets for the service account
  imagePullSecrets: []
  # -- Annotations for the service account
  annotations: {}
  # -- Labels for the service account
  labels: {}
  # -- Set this toggle to false to opt out of automounting API credentials for the service account
  automountServiceAccountToken: true
# RBAC configuration
rbac:
  # -- If pspEnabled true, a PodSecurityPolicy is created for K8s that use psp.
  pspEnabled: false
  # -- For OpenShift set pspEnabled to 'false' and sccEnabled to 'true' to use the SecurityContextConstraints.
  sccEnabled: false
  # -- Specify PSP annotations
  # Ref: https://kubernetes.io/docs/reference/access-authn-authz/psp-to-pod-security-standards/#podsecuritypolicy-annotations
  pspAnnotations: {}
  # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
  # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
  # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'
  # -- Whether to install RBAC in the namespace only or cluster-wide. Useful if you want to watch ConfigMap globally.
  namespaced: false
######################################################################################################################
#
# Network Policy configuration
#
######################################################################################################################
networkPolicy:
  # -- Specifies whether Network Policies should be created
  enabled: false
  # -- Specifies whether the policies created will be standard Network Policies (flavor: kubernetes)
  # or Cilium Network Policies (flavor: cilium)
  flavor: kubernetes
  metrics:
    # -- Specifies the Pods which are allowed to access the metrics port.
    # As this is cross-namespace communication, you also need the namespaceSelector.
    podSelector: {}
    # -- Specifies the namespaces which are allowed to access the metrics port
    namespaceSelector: {}
    # -- Specifies specific network CIDRs which are allowed to access the metrics port.
    # In case you use namespaceSelector, you also have to specify your kubelet networks here.
    # The metrics ports are also used for probes.
    cidrs: []
  ingress:
    # -- Specifies the Pods which are allowed to access the http port.
    # As this is cross-namespace communication, you also need the namespaceSelector.
    podSelector: {}
    # -- Specifies the namespaces which are allowed to access the http port
    namespaceSelector: {}
  alertmanager:
    # -- Specify the alertmanager port used for alerting
    port: 9093
    # -- Specifies the alertmanager Pods.
    # As this is cross-namespace communication, you also need the namespaceSelector.
    podSelector: {}
    # -- Specifies the namespace the alertmanager is running in
    namespaceSelector: {}
  externalStorage:
    # -- Specify the port used for external storage, e.g. AWS S3
    ports: []
    # -- Specifies specific network CIDRs you want to limit access to
    cidrs: []
  discovery:
    # -- (int) Specify the port used for discovery
    port: null
    # -- Specifies the Pods labels used for discovery.
    # As this is cross-namespace communication, you also need the namespaceSelector.
    podSelector: {}
    # -- Specifies the namespace the discovery Pods are running in
    namespaceSelector: {}
  egressWorld:
    # -- Enable additional cilium egress rules to external world for write, read and backend.
    enabled: false
  egressKubeApiserver:
    # -- Enable additional cilium egress rules to kube-apiserver for backend.
    enabled: false
######################################################################################################################
#
# Global memberlist configuration
#
######################################################################################################################

# Configuration for the memberlist service
memberlist:
  service:
    publishNotReadyAddresses: false
######################################################################################################################
#
# adminAPI configuration, enterprise only.
#
######################################################################################################################

# # -- Configuration for the `admin-api` target
# adminApi:
#   # -- Define the amount of instances
#   replicas: 1
#   # -- hostAliases to add
#   hostAliases: []
#   #  - ip: 1.2.3.4
#   #    hostnames:
#   #      - domain.tld
#   # -- Additional CLI arguments for the `admin-api` target
#   extraArgs: {}
#   # -- Additional labels for the `admin-api` Deployment
#   labels: {}
#   # -- Additional annotations for the `admin-api` Deployment
#   annotations: {}
#   # -- Additional labels and annotations for the `admin-api` Service
#   service:
#     labels: {}
#     annotations: {}
#   # -- Run container as user `enterprise-logs(uid=10001)`
#   # `fsGroup` must not be specified, because these security options are applied
#   # on container level not on Pod level.
#   podSecurityContext:
#     runAsNonRoot: true
#     runAsGroup: 10001
#     runAsUser: 10001
#   containerSecurityContext:
#     readOnlyRootFilesystem: true
#     capabilities:
#       drop:
#       - ALL
#     allowPrivilegeEscalation: false
#   # -- Update strategy
#   strategy:
#     type: RollingUpdate
#   # -- Readiness probe
#   readinessProbe:
#     httpGet:
#       path: /ready
#       port: http-metrics
#     initialDelaySeconds: 45
#   # -- Request and limit Kubernetes resources
#   # -- Values are defined in small.yaml and large.yaml
#   resources: {}
#   # -- Configure optional environment variables
#   env: []
#   # -- Configure optional initContainers
#   initContainers: []
#   # -- Conifgure optional extraContainers
#   extraContainers: []
#   # -- Additional volumes for Pods
#   extraVolumes: []
#   # -- Additional volume mounts for Pods
#   extraVolumeMounts: []
#   # -- Affinity for admin-api Pods
#   affinity: {}
#   # -- Node selector for admin-api Pods
#   nodeSelector: {}
#   # -- Tolerations for admin-api Pods
#   tolerations: []
#   # -- Grace period to allow the admin-api to shutdown before it is killed
#   terminationGracePeriodSeconds: 60


######################################################################################################################
#
# Gateway and Ingress
#
# By default this chart will deploy a Nginx container to act as a gateway which handles routing of traffic
# and can also do auth.
#
# If you would prefer you can optionally disable this and enable using k8s ingress to do the incoming routing.
#
######################################################################################################################

# Configuration for the gateway
gateway:
  # -- Specifies whether the gateway should be enabled
  enabled: true
  # -- Number of replicas for the gateway
  replicas: 1
  # -- Enable logging of 2xx and 3xx HTTP requests
  verboseLogging: true
  autoscaling:
    # -- Enable autoscaling for the gateway
    enabled: false
    # -- Minimum autoscaling replicas for the gateway
    minReplicas: 1
    # -- Maximum autoscaling replicas for the gateway
    maxReplicas: 3
    # -- Target CPU utilisation percentage for the gateway
    targetCPUUtilizationPercentage: 60
    # -- Target memory utilisation percentage for the gateway
    targetMemoryUtilizationPercentage:
    # -- See `kubectl explain deployment.spec.strategy` for more
    # -- ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
    # -- Behavior policies while scaling.
    behavior: {}
    #    scaleUp:
  #     stabilizationWindowSeconds: 300
  #     policies:
  #     - type: Pods
  #       value: 1
  #       periodSeconds: 60
  #    scaleDown:
  #     stabilizationWindowSeconds: 300
  #     policies:
  #     - type: Pods
  #       value: 1
  #       periodSeconds: 180
  deploymentStrategy:
    type: RollingUpdate
  image:
    # -- The Docker registry for the gateway image
    registry: docker.io
    # -- The gateway image repository
    repository: nginxinc/nginx-unprivileged
    # -- The gateway image tag
    tag: 1.24-alpine
    # -- Overrides the gateway image tag with an image digest
    digest: null
    # -- The gateway image pull policy
    pullPolicy: IfNotPresent
  # -- The name of the PriorityClass for gateway pods
  priorityClassName: null
  # -- Annotations for gateway deployment
  annotations: {}
  # -- Annotations for gateway pods
  podAnnotations: {}
  # -- Additional labels for gateway pods
  podLabels: {}
  # -- Additional CLI args for the gateway
  extraArgs:
  - -validation.max-entries-limit=20000
  - -querier.engine.timeout=5m
  - -querier.query-timeout=5m
  - -server.http-read-timeout=5m
  - -server.http-write-timeout=5m
  # -- Environment variables to add to the gateway pods
  extraEnv: []
  # -- Environment variables from secrets or configmaps to add to the gateway pods
  extraEnvFrom: []
  # -- Lifecycle for the gateway container
  lifecycle: {}
  # -- Volumes to add to the gateway pods
  extraVolumes: []
  # -- Volume mounts to add to the gateway pods
  extraVolumeMounts: []
  # -- The SecurityContext for gateway containers
  podSecurityContext:
    fsGroup: 101
    runAsGroup: 101
    runAsNonRoot: true
    runAsUser: 101
  # -- The SecurityContext for gateway containers
  containerSecurityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop:
      - ALL
    allowPrivilegeEscalation: false
  # -- Resource requests and limits for the gateway
  resources: {}
  # -- Containers to add to the gateway pods
  extraContainers: []
  # -- Grace period to allow the gateway to shutdown before it is killed
  terminationGracePeriodSeconds: 30
  # -- Affinity for gateway pods.
  # @default -- Hard node anti-affinity
  # affinity:
  #   podAntiAffinity:
  #     requiredDuringSchedulingIgnoredDuringExecution:
  #     - labelSelector:
  #         matchLabels:
  #           app.kubernetes.io/component: gateway
  #       topologyKey: kubernetes.io/hostname
  # -- DNS config for gateway pods
  dnsConfig: {}
  # -- Node selector for gateway pods
  nodeSelector: {}
  # -- Topology Spread Constraints for gateway pods
  topologySpreadConstraints: []
  # -- Tolerations for gateway pods
  tolerations: []
  # Gateway service configuration
  service:
    # -- Port of the gateway service
    port: 80
    # -- Type of the gateway service
    type: ClusterIP
    # -- ClusterIP of the gateway service
    clusterIP: null
    # -- (int) Node port if service type is NodePort
    nodePort: null
    # -- Load balancer IPO address if service type is LoadBalancer
    loadBalancerIP: null
    # -- Annotations for the gateway service
    annotations: {}
    # -- Labels for gateway service
    labels: {}
  # Gateway ingress configuration
  ingress:
    # -- Specifies whether an ingress for the gateway should be created
    enabled: false
    # -- Ingress Class Name. MAY be required for Kubernetes versions >= 1.18
    ingressClassName: ""
    # -- Annotations for the gateway ingress
    annotations: {}
    # -- Labels for the gateway ingress
    labels: {}
    # -- Hosts configuration for the gateway ingress, passed through the `tpl` function to allow templating
    hosts:
    - host: gateway.loki.example.com
      paths:
      - path: /
        # -- pathType (e.g. ImplementationSpecific, Prefix, .. etc.) might also be required by some Ingress Controllers
    # pathType: Prefix
    # -- TLS configuration for the gateway ingress. Hosts passed through the `tpl` function to allow templating
    # tls:
    # - secretName: loki-gateway-tls
    #   hosts:
    #   - gateway.loki.example.com
  # Basic auth configuration
  basicAuth:
    # -- Enables basic authentication for the gateway
    enabled: false
    # -- The basic auth username for the gateway
    username: null
    # -- The basic auth password for the gateway
    password: null
    # -- Uses the specified users from the `loki.tenants` list to create the htpasswd file
    # if `loki.tenants` is not set, the `gateway.basicAuth.username` and `gateway.basicAuth.password` are used
    # The value is templated using `tpl`. Override this to use a custom htpasswd, e.g. in case the default causes
    # high CPU load.
    htpasswd: >-
      {{ if .Values.loki.tenants }}


        {{- range $t := .Values.loki.tenants }}
      {{ htpasswd (required "All tenants must have a 'name' set" $t.name) (required "All tenants must have a 'password' set" $t.password) }}


        {{- end }}
      {{ else }} {{ htpasswd (required "'gateway.basicAuth.username' is required" .Values.gateway.basicAuth.username) (required "'gateway.basicAuth.password' is required" .Values.gateway.basicAuth.password) }} {{ end }}
    # -- Existing basic auth secret to use. Must contain '.htpasswd'
    existingSecret: null
  # Configures the readiness probe for the gateway
  readinessProbe:
    httpGet:
      path: /
      port: http-metrics
    initialDelaySeconds: 15
    timeoutSeconds: 1
  nginxConfig:
    # -- Which schema to be used when building URLs. Can be 'http' or 'https'.
    schema: http
    # -- Enable listener for IPv6, disable on IPv4-only systems
    enableIPv6: false
    # -- NGINX log format
    logFormat: |-
      main '$remote_addr - $remote_user [$time_local]  $status '
              '"$request" $body_bytes_sent "$http_referer" '
              '"$http_user_agent" "$http_x_forwarded_for"';
    # -- Allows appending custom configuration to the server block
    serverSnippet: ""
    # -- Allows appending custom configuration to the http block, passed through the `tpl` function to allow templating
    httpSnippet: >-
      {{ if .Values.loki.tenants }}proxy_set_header X-Scope-OrgID $remote_user;{{ end }}
    # -- Whether ssl should be appended to the listen directive of the server block or not.
    ssl: false
    # -- Override Read URL
    customReadUrl: null
    # -- Override Write URL
    customWriteUrl: null
    # -- Override Backend URL
    customBackendUrl: null
    # -- Allows overriding the DNS resolver address nginx will use.
    resolver: ""
    # -- Config file contents for Nginx. Passed through the `tpl` function to allow templating
    # @default -- See values.yaml
    file: |
      {{- include "loki.nginxFile" . | indent 2 -}}
# -- If running enterprise and using the default enterprise gateway, configs go here.
# enterpriseGateway:
#   # -- Define the amount of instances
#   replicas: 1
#   # -- hostAliases to add
#   hostAliases: []
#   #  - ip: 1.2.3.4
#   #    hostnames:
#   #      - domain.tld
#   # -- Additional CLI arguments for the `gateway` target
#   extraArgs: {}
#   # -- Additional labels for the `gateway` Pod
#   labels: {}
#   # -- Additional annotations for the `gateway` Pod
#   annotations: {}
#   # -- Additional labels and annotations for the `gateway` Service
#   # -- Service overriding service type
#   service:
#     type: ClusterIP
#     labels: {}
#     annotations: {}
#   # -- Run container as user `enterprise-logs(uid=10001)`
#   podSecurityContext:
#     runAsNonRoot: true
#     runAsGroup: 10001
#     runAsUser: 10001
#     fsGroup: 10001
#   containerSecurityContext:
#     readOnlyRootFilesystem: true
#     capabilities:
#       drop:
#       - ALL
#     allowPrivilegeEscalation: false
#   # -- If you want to use your own proxy URLs, set this to false.
#   useDefaultProxyURLs: true
#   # -- update strategy
#   strategy:
#     type: RollingUpdate
#   # -- Readiness probe
#   readinessProbe:
#     httpGet:
#       path: /ready
#       port: http-metrics
#     initialDelaySeconds: 45
#   # -- Request and limit Kubernetes resources
#   # -- Values are defined in small.yaml and large.yaml
#   resources: {}
#   # -- Configure optional environment variables
#   env: []
#   # -- Configure optional initContainers
#   initContainers: []
#   # -- Conifgure optional extraContainers
#   extraContainers: []
#   # -- Additional volumes for Pods
#   extraVolumes: []
#   # -- Additional volume mounts for Pods
#   extraVolumeMounts: []
#   # -- Affinity for gateway Pods
#   affinity: {}
#   # -- Node selector for gateway Pods
#   nodeSelector: {}
#   # -- Tolerations for gateway Pods
#   tolerations: []
#   # -- Grace period to allow the gateway to shutdown before it is killed
#   terminationGracePeriodSeconds: 60
# -- Ingress configuration Use either this ingress or the gateway, but not both at once.
# If you enable this, make sure to disable the gateway.
# You'll need to supply authn configuration for your ingress controller.
ingress:
  enabled: false
  ingressClassName: ""
  annotations: {}
  #    nginx.ingress.kubernetes.io/auth-type: basic
  #    nginx.ingress.kubernetes.io/auth-secret: loki-distributed-basic-auth
  #    nginx.ingress.kubernetes.io/auth-secret-type: auth-map
  #    nginx.ingress.kubernetes.io/configuration-snippet: |
  #      proxy_set_header X-Scope-OrgID $remote_user;
  labels: {}
  #    blackbox.monitoring.exclude: "true"
  paths:
    write:
    - /api/prom/push
    - /loki/api/v1/push
    read:
    - /api/prom/tail
    - /loki/api/v1/tail
    - /loki/api
    - /api/prom/rules
    - /loki/api/v1/rules
    - /prometheus/api/v1/rules
    - /prometheus/api/v1/alerts
    singleBinary:
    - /api/prom/push
    - /loki/api/v1/push
    - /api/prom/tail
    - /loki/api/v1/tail
    - /loki/api
    - /api/prom/rules
    - /loki/api/v1/rules
    - /prometheus/api/v1/rules
    - /prometheus/api/v1/alerts
  # -- Hosts configuration for the ingress, passed through the `tpl` function to allow templating
  hosts:
  - loki.example.com
  # -- TLS configuration for the ingress. Hosts passed through the `tpl` function to allow templating
  tls: []
#    - hosts:
#       - loki.example.com
#      secretName: loki-distributed-tls

######################################################################################################################
#
# Migration
#
######################################################################################################################

# -- Options that may be necessary when performing a migration from another helm chart
# migrate:
#   # -- When migrating from a distributed chart like loki-distributed or enterprise-logs
#   fromDistributed:
#     # -- Set to true if migrating from a distributed helm chart
#     enabled: false
#     # -- If migrating from a distributed service, provide the distributed deployment's
#     # memberlist service DNS so the new deployment can join its ring.
#     memberlistService: ""

######################################################################################################################
#
# Single Binary Deployment
#
# For small Loki installations up to a few 10's of GB per day, or for testing and development.
#
######################################################################################################################

# Configuration for the single binary node(s)
singleBinary:
  # -- Number of replicas for the single binary
  replicas: 1
  autoscaling:
    # -- Enable autoscaling
    enabled: false
    # -- Minimum autoscaling replicas for the single binary
    minReplicas: 1
    # -- Maximum autoscaling replicas for the single binary
    maxReplicas: 3
    # -- Target CPU utilisation percentage for the single binary
    targetCPUUtilizationPercentage: 60
    # -- Target memory utilisation percentage for the single binary
    targetMemoryUtilizationPercentage:
  image:
    # -- The Docker registry for the single binary image. Overrides `loki.image.registry`
    registry: null
    # -- Docker image repository for the single binary image. Overrides `loki.image.repository`
    repository: null
    # -- Docker image tag for the single binary image. Overrides `loki.image.tag`
    tag: null
  # -- The name of the PriorityClass for single binary pods
  priorityClassName: null
  # -- Annotations for single binary StatefulSet
  annotations: {}
  # -- Annotations for single binary pods
  podAnnotations: {}
  # -- Additional labels for each `single binary` pod
  podLabels: {}
  # -- Additional selector labels for each `single binary` pod
  selectorLabels: {}
  service:
    # -- Annotations for single binary Service
    annotations: {}
    # -- Additional labels for single binary Service
    labels: {}
  # -- Comma-separated list of Loki modules to load for the single binary
  targetModule: "all"
  # -- Labels for single binary service
  extraArgs: []
  # -- Environment variables to add to the single binary pods
  extraEnv: []
  # -- Environment variables from secrets or configmaps to add to the single binary pods
  extraEnvFrom: []
  # -- Extra containers to add to the single binary loki pod
  extraContainers: []
  # -- Init containers to add to the single binary pods
  initContainers: []
  # -- Volume mounts to add to the single binary pods
  extraVolumeMounts: []
  # -- Volumes to add to the single binary pods
  extraVolumes: []
  # -- Resource requests and limits for the single binary
  resources: {}
  # -- Grace period to allow the single binary to shutdown before it is killed
  terminationGracePeriodSeconds: 30
  # -- Affinity for single binary pods.
  # @default -- Hard node anti-affinity
  # affinity:
  #   podAntiAffinity:
  #     requiredDuringSchedulingIgnoredDuringExecution:
  #     - labelSelector:
  #         matchLabels:
  #           app.kubernetes.io/component: single-binary
  #       topologyKey: kubernetes.io/hostname
  # -- DNS config for single binary pods
  dnsConfig: {}
  # -- Node selector for single binary pods
  nodeSelector: {}
  # -- Tolerations for single binary pods
  tolerations: []
  persistence:
    # -- Enable StatefulSetAutoDeletePVC feature
    enableStatefulSetAutoDeletePVC: true
    # -- Enable persistent disk
    enabled: true
    # -- Size of persistent disk
    size: 2Gi
    # -- Storage class to be used.
    # If defined, storageClassName: <storageClass>.
    # If set to "-", storageClassName: "", which disables dynamic provisioning.
    # If empty or set to null, no storageClassName spec is
    # set, choosing the default provisioner (gp2 on AWS, standard on GKE, AWS, and OpenStack).
    storageClass: null
    # -- Selector for persistent disk
    selector: null

######################################################################################################################
#
# Subchart configurations
#
######################################################################################################################
# -- Setting for the Grafana Rollout Operator https://github.com/grafana/helm-charts/tree/main/charts/rollout-operator
rollout_operator:
  enabled: false
  # -- podSecurityContext is the pod security context for the rollout operator.
  # When installing on OpenShift, override podSecurityContext settings with
  #
  # rollout_operator:
  #   podSecurityContext:
  #     fsGroup: null
  #     runAsGroup: null
  #     runAsUser: null
  podSecurityContext:
    fsGroup: 10001
    runAsGroup: 10001
    runAsNonRoot: true
    runAsUser: 10001
    seccompProfile:
      type: RuntimeDefault
  # Set the container security context
  securityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop: [ALL]
    allowPrivilegeEscalation: false
# -- Configuration for the minio subchart
minio:
  enabled: false
  replicas: 1
  # Minio requires 2 to 16 drives for erasure code (drivesPerNode * replicas)
  # https://docs.min.io/docs/minio-erasure-code-quickstart-guide
  # Since we only have 1 replica, that means 2 drives must be used.
  drivesPerNode: 2
  rootUser: enterprise-logs
  rootPassword: supersecret
  buckets:
  - name: chunks
    policy: none
    purge: false
  - name: ruler
    policy: none
    purge: false
  - name: admin
    policy: none
    purge: false
  persistence:
    size: 1Gi
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
  # Allow the address used by Loki to refer to Minio to be overridden
  address: null
# Create extra manifests via values. Would be passed through `tpl` for templating
extraObjects: []
# - apiVersion: v1
#   kind: ConfigMap
#   metadata:
#     name: loki-alerting-rules
#   data:
#     loki-alerting-rules.yaml: |-
#       groups:
#         - name: example
#           rules:
#           - alert: example
#             expr: |
#               sum(count_over_time({app="loki"} |~ "error")) > 0
#             for: 3m
#             labels:
#               severity: warning
#               category: logs
#             annotations:
#               message: "loki has encountered errors"

sidecar:
  image:
    # -- The Docker registry and image for the k8s sidecar
    repository: kiwigrid/k8s-sidecar
    # -- Docker image tag
    tag: 1.24.3
    # -- Docker image sha. If empty, no sha will be used
    sha: ""
    # -- Docker image pull policy
    pullPolicy: IfNotPresent
  # -- Resource requests and limits for the sidecar
  resources:
    limits:
      cpu: 100m
      memory: 100Mi
    requests:
      cpu: 50m
      memory: 50Mi
  # -- The SecurityContext for the sidecar.
  securityContext: {}
  # -- Set to true to skip tls verification for kube api calls.
  skipTlsVerify: false
  # -- Ensure that rule files aren't conflicting and being overwritten by prefixing their name with the namespace they are defined in.
  enableUniqueFilenames: false
  # -- Readiness probe definition. Probe is disabled on the sidecar by default.
  readinessProbe: {}
  # -- Liveness probe definition. Probe is disabled on the sidecar by default.
  livenessProbe: {}
  rules:
    # -- Whether or not to create a sidecar to ingest rule from specific ConfigMaps and/or Secrets.
    enabled: true
    # -- Label that the configmaps/secrets with rules will be marked with.
    label: loki_rule
    # -- Label value that the configmaps/secrets with rules will be set to.
    labelValue: ""
    # -- Folder into which the rules will be placed.
    folder: /rules
    # -- Comma separated list of namespaces. If specified, the sidecar will search for config-maps/secrets inside these namespaces.
    # Otherwise the namespace in which the sidecar is running will be used.
    # It's also possible to specify 'ALL' to search in all namespaces.
    searchNamespace: null
    # -- Method to use to detect ConfigMap changes. With WATCH the sidecar will do a WATCH request, with SLEEP it will list all ConfigMaps, then sleep for 60 seconds.
    watchMethod: WATCH
    # -- Search in configmap, secret, or both.
    resource: both
    # -- Absolute path to the shell script to execute after a configmap or secret has been reloaded.
    script: null
    # -- WatchServerTimeout: request to the server, asking it to cleanly close the connection after that.
    # defaults to 60sec; much higher values like 3600 seconds (1h) are feasible for non-Azure K8S.
    watchServerTimeout: 60
    #
    # -- WatchClientTimeout: is a client-side timeout, configuring your local socket.
    # If you have a network outage dropping all packets with no RST/FIN,
    # this is how long your client waits before realizing & dropping the connection.
    # Defaults to 66sec.
    watchClientTimeout: 60
    # -- Log level of the sidecar container.
    logLevel: INFO

######################################################################################################################
#
# Simple Scalable Deployment (SSD) Mode
#
# For small to medium size Loki deployments up to around 1 TB/day, this is the default mode for this helm chart
#
######################################################################################################################

# Configuration for the write pod(s)
write:
  # -- Number of replicas for the write
  replicas: 0
read:
  # -- Number of replicas for the read
  replicas: 0
backend:
  replicas: 0
